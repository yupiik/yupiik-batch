[{"lang":"en","lvl2":"Installation\nLearning about chain and component API","text":"Ensure to use java >= 17.\nIf you want to compile the project you need Git and Apache Maven.\nyou can use SDKMan to install Java and Maven.\nTo learn more about what the project provides, you can read Write your first batch guide.","title":"Getting Started","url":"//yupiik.github.io/yupiik-batch/getting-started.html"},{"lang":"en","text":"","title":"Index","url":"//yupiik.github.io/yupiik-batch/index.html"},{"lang":"en","lvl2":"Dependency\nConfiguration\nExtend the UI","text":"The dependency to use is:\nYou can add any JDBC driver you want too. Once you have it, you can create a Docker image using the main org.apache.openwebbeans.se.CDILauncher - just use the previous classpath.\nusing jib the docker image creation is very smooth.\nName\nEnv Variable\nDescription\nyupiik.batch.backend.database.jobTable\nYUPIIK_BATCH_BACKEND_DATABASE_JOBTABLE\nJob table to query.\nyupiik.batch.backend.database.stepTable\nYUPIIK_BATCH_BACKEND_DATABASE_STEPTABLE\nStep table to query.\nyupiik.batch.backend.datasource.driver *\nYUPIIK_BATCH_BACKEND_DATASOURCE_DRIVER\nDatasource driver.\nyupiik.batch.backend.datasource.maxConnections\nYUPIIK_BATCH_BACKEND_DATASOURCE_MAXCONNECTIONS\nMax connections in the pool.\nyupiik.batch.backend.datasource.minEvictableIdleTime\nYUPIIK_BATCH_BACKEND_DATASOURCE_MINEVICTABLEIDLETIME\nHow long to await before a connection is considered idled and evictable.\nyupiik.batch.backend.datasource.minIdle\nYUPIIK_BATCH_BACKEND_DATASOURCE_MINIDLE\nMin connections in the pool.\nyupiik.batch.backend.datasource.password\nYUPIIK_BATCH_BACKEND_DATASOURCE_PASSWORD\nDatasource password.\nyupiik.batch.backend.datasource.removeAbandoned\nYUPIIK_BATCH_BACKEND_DATASOURCE_REMOVEABANDONED\nShould connections be removed when abandoned (see related timeout).\nyupiik.batch.backend.datasource.removeAbandonedTimeout\nYUPIIK_BATCH_BACKEND_DATASOURCE_REMOVEABANDONEDTIMEOUT\nThe time in seconds before a connection can be considered abandoned.\nyupiik.batch.backend.datasource.testOnBorrow\nYUPIIK_BATCH_BACKEND_DATASOURCE_TESTONBORROW\nShould connections be tested on borrow time.\nyupiik.batch.backend.datasource.testOnReturn\nYUPIIK_BATCH_BACKEND_DATASOURCE_TESTONRETURN\nShould connections be tested on return to the pool time.\nyupiik.batch.backend.datasource.testWhileIdle\nYUPIIK_BATCH_BACKEND_DATASOURCE_TESTWHILEIDLE\nShould connections be tested in background.\nyupiik.batch.backend.datasource.timeBetweenEvictionRuns\nYUPIIK_BATCH_BACKEND_DATASOURCE_TIMEBETWEENEVICTIONRUNS\nTime between background evictions in ms.\nyupiik.batch.backend.datasource.url *\nYUPIIK_BATCH_BACKEND_DATASOURCE_URL\nDatasource URL.\nyupiik.batch.backend.datasource.username\nYUPIIK_BATCH_BACKEND_DATASOURCE_USERNAME\nDatasource username.\nyupiik.batch.backend.datasource.validationQuery\nYUPIIK_BATCH_BACKEND_DATASOURCE_VALIDATIONQUERY\nValidation query to validate the connection when enabled.\nyupiik.batch.backend.datasource.validationQueryTimeout\nYUPIIK_BATCH_BACKEND_DATASOURCE_VALIDATIONQUERYTIMEOUT\nHow long to await for the validation query.\nyupiik.batch.backend.queries.countAllJobs\nYUPIIK_BATCH_BACKEND_QUERIES_COUNTALLJOBS\nCount all jobs SQL query (for portability), ${table} is replaced by the table name.\nyupiik.batch.backend.queries.findAllJobs\nYUPIIK_BATCH_BACKEND_QUERIES_FINDALLJOBS\nFind all jobs with pagination SQL query (for portability), ${table} is replaced by the table name. Parameters can be ${pageSize}, ${firstIndex} - inclusive, ${lastIndex} - exclusive, or ${where} which would be replaced by a name where clause (`WHERE name = ? `).\nyupiik.batch.backend.queries.findJobById\nYUPIIK_BATCH_BACKEND_QUERIES_FINDJOBBYID\nFind a job by id SQL query (for portability), ${table} is replaced by the table name.\nyupiik.batch.backend.queries.findLastExecutions\nYUPIIK_BATCH_BACKEND_QUERIES_FINDLASTEXECUTIONS\nSQL query (for portability) to find last execution of each batch, ${table} is replaced by the table name.\nyupiik.batch.backend.queries.findStepsByJobId\nYUPIIK_BATCH_BACKEND_QUERIES_FINDSTEPSBYJOBID\nFind aall steps related to a job id SQL query (for portability), ${table} is replaced by the step table name.\nyupiik.batch.backend.tomcat.accessLogPattern\nYUPIIK_BATCH_BACKEND_TOMCAT_ACCESSLOGPATTERN\nTomcat access log pattern.\nyupiik.batch.backend.tomcat.port\nYUPIIK_BATCH_BACKEND_TOMCAT_PORT\nTomcat port.\nyupiik.batch.backend.tomcat.webUsers\nYUPIIK_BATCH_BACKEND_TOMCAT_WEBUSERS\nList of allowed users - by default all are. It uses a properties syntax: user=password. Security uses a web BASIC mecanism.\nyupiik.batch.frontend.extensionsJs\nYUPIIK_BATCH_FRONTEND_EXTENSIONSJS\nJavascript path to a Yupiik Batch frontend extension. Script is injected just before yupiik-batch main one, i.e. after libraries ones but note they are minified wih webpack.\nThe UI provides a few extension points to let you enrich it with other utilities.\nFirst step is to create a javascript file which will register the extension then use the related configuration to let the server inject it into the index.html.\nAn extension often looks like:\nReact, react-router, useJsonRpc - a hook to call JSON-RPC server, andt - components, and antdIcons are injected in extension points to let you integrate with the application UI.","title":"UI","url":"//yupiik.github.io/yupiik-batch/ui.html"},{"lang":"en","lvl2":"Create a batch\nDefine your batch configuration\nReusable batch components\nReusable Iterators\nio.yupiik.batch.iterator.excel.component.ExcelIterator\nTIP","lvl3":"io.yupiik.batch.runtime.component.AcceptedLossDiffFilter\nio.yupiik.batch.runtime.component.DatasetDiffComputer\nio.yupiik.batch.runtime.component.DiffExecutor\nio.yupiik.batch.runtime.component.Mapper\nio.yupiik.batch.runtime.component.SQLQuery\nio.yupiik.batch.runtime.component.uship.DatabaseDiffExecutor\nCombine components\nFactories\nDependency","text":"Implementing a batch is about extending Batch interface:\nWhat is important to note is that a batch has a configuration and the configuration is \"injected\" in accept method. This enables the framework to map the main arguments to the configuration in an unified fashion.\nOnce you have a batch implementation, you can run it using Batch launcher method:\nA batch configuration is a class with field(s) decorated with @Param:\nfields are injected so they shouldn’t be final but there is no constraint on having getters/setters.\nio.yupiik.batch.runtime.documentation.ConfigurationParameterCollector class enables to extract all parameters for a batch and then map this extraction to a documentation if needed.\nsimple-configuration package enables to use this configuration without all the batch stack.\nReusable components are in io.yupiik.batch.runtime.component package. This section highlights a few of them.\nEnables to filter a Diff. If the acceptedLoss is not reached, i.e. more row would be deleted than this percentage, the chain will end there.\nGoal is to not delete a database if incoming data are corrupted or not properly up to date.\nComponent which takes as input two iterators representing sorted datasets.\nBoth dataset will be compared - in streaming mode - using the Comparator passed in the constructor/factory method. It enables to detect deletions and additions and it will be reflected in the resulting Diff instance.\nIf equals, the BiPredicate will be used to check it is actually equal or not. If not the data will be considered updated, otherwise not changed and ignored from the diff.\nEnables to apply a Diff - from a DatasetDiffComputer.\nIt will apply it in a database represented by the connectionSupplier with the provided commitInterval. The statements are creating using the related factories - insertFactory, updateFactory, deleteFactory.\nFinally, dryRun toggle enables to simulate the processing without issuing any modification in the database.\nThis mapping component enables to convert an input to an output instance by providing an specification instance.\nIt is a class decorated with @Mapping:\nTo get a mapper, you simply call Mapper.mapper(MyMapperSpec.class) and then can insert this mapper in any BatchChain.\nThe specification API enables static mapping (properties) or custom mapping - @Mapping.Custom - for more advanced logic.\nThe companion class io.yupiik.batch.runtime.documentation.MapperDocGenerator enables to generate an asciidoctor documentation for a mapper class.\nEnables to extract data from a SQL query.\nA custom mapper will be called for each ResultSet line to convert current row in an object passed to the rest of the BatchChain.\nEnables to apply a Diff - from a DatasetDiffComputer when the entities (diff model) are Yupiik UShip Persistence models.\nIt will apply it in a database with the provided commitInterval.\ndryRun toggle enables to simulate the processing without issuing any modification in the database.\nCombining components can be done in a plain main:\nHowever, for too noisy cases, it can be neat to use a fluent API on the diff to make it more readable and composable. Indeed you can use the Stream or Optional API:\nThis enables to read more explicitly the flow of processing thanks Stream or Optional fluent API. It is also now easier to insert an element or decorate components explicitly.\nHowever, these two API are not designed for that and will quickly hit some limitation. To make it more batch oriented, parent Batch class enables to define a stream like flow but more batch oriented. You have to start your flow by from() or use a specific source such as DatasetDiffComputer. For example:\nThis DSL is more friendly to the batches we write (integrating with default components).\nuntil you hit run() nothing is done.\nsome components have a static factory to make it more expressive, don’t hesitate to use it.\nFinally, the RunConfiguration enables to intercept any step of the BatchChain defined by the previous DSL. Combined with ExecutionTracer, it will let you store any execution and its steps in a database for audit or monitoring/administration purposes.\nReusable iterators are either provided through FluentIterator or extensions (in this case you must add a dependency to get it).\nReads an excel file sheet row by row.\nCreates a new ExcelIterator with a custom row mapper.\nCreates a new ExcelIterator with a default row mapper mapping lines as List<String>.\nUse FluentIterator to filter and map your input Iterator, it makes the code more readable and adds some features Stream does not have like a more advanced distinct implementation.\nHere is a sample input iterator written using FluentIterator and filtering its data with some business rule on the raw input and post processing the mapped data with PspRolePasswordInjector.\nCreate a FluentIterator from myIterator() result,\nFilter the iterator with a Predicate,\nMap the iterator data to another model with a `Mapper>,\nRemove the enclosing FluentIterator wrapper which is not needed once the full iterator chain is defined (optional).","title":"Write your first batch","url":"//yupiik.github.io/yupiik-batch/write-your-first-batch.html"},{"lang":"en","lvl3":"io.yupiik.batch.runtime.component.AcceptedLossDiffFilter\nio.yupiik.batch.runtime.component.DatasetDiffComputer\nio.yupiik.batch.runtime.component.DiffExecutor\nio.yupiik.batch.runtime.component.Mapper\nio.yupiik.batch.runtime.component.SQLQuery\nio.yupiik.batch.runtime.component.uship.DatabaseDiffExecutor","text":"Enables to filter a Diff. If the acceptedLoss is not reached, i.e. more row would be deleted than this percentage, the chain will end there.\nGoal is to not delete a database if incoming data are corrupted or not properly up to date.\nComponent which takes as input two iterators representing sorted datasets.\nBoth dataset will be compared - in streaming mode - using the Comparator passed in the constructor/factory method. It enables to detect deletions and additions and it will be reflected in the resulting Diff instance.\nIf equals, the BiPredicate will be used to check it is actually equal or not. If not the data will be considered updated, otherwise not changed and ignored from the diff.\nEnables to apply a Diff - from a DatasetDiffComputer.\nIt will apply it in a database represented by the connectionSupplier with the provided commitInterval. The statements are creating using the related factories - insertFactory, updateFactory, deleteFactory.\nFinally, dryRun toggle enables to simulate the processing without issuing any modification in the database.\nThis mapping component enables to convert an input to an output instance by providing an specification instance.\nIt is a class decorated with @Mapping:\nTo get a mapper, you simply call Mapper.mapper(MyMapperSpec.class) and then can insert this mapper in any BatchChain.\nThe specification API enables static mapping (properties) or custom mapping - @Mapping.Custom - for more advanced logic.\nThe companion class io.yupiik.batch.runtime.documentation.MapperDocGenerator enables to generate an asciidoctor documentation for a mapper class.\nEnables to extract data from a SQL query.\nA custom mapper will be called for each ResultSet line to convert current row in an object passed to the rest of the BatchChain.\nEnables to apply a Diff - from a DatasetDiffComputer when the entities (diff model) are Yupiik UShip Persistence models.\nIt will apply it in a database with the provided commitInterval.\ndryRun toggle enables to simulate the processing without issuing any modification in the database.","title":"Yupiik Yupiik Batch","url":"//yupiik.github.io/yupiik-batch/generated/components.html"},{"lang":"en","lvl2":"io.yupiik.batch.iterator.excel.component.ExcelIterator","lvl3":"Factories\nDependency","text":"Reads an excel file sheet row by row.\nCreates a new ExcelIterator with a custom row mapper.\nCreates a new ExcelIterator with a default row mapper mapping lines as List<String>.","title":"Yupiik Yupiik Batch","url":"//yupiik.github.io/yupiik-batch/generated/iterators.html"},{"lang":"en","text":"Name\nEnv Variable\nDescription\nyupiik.batch.backend.database.jobTable\nYUPIIK_BATCH_BACKEND_DATABASE_JOBTABLE\nJob table to query.\nyupiik.batch.backend.database.stepTable\nYUPIIK_BATCH_BACKEND_DATABASE_STEPTABLE\nStep table to query.\nyupiik.batch.backend.datasource.driver *\nYUPIIK_BATCH_BACKEND_DATASOURCE_DRIVER\nDatasource driver.\nyupiik.batch.backend.datasource.maxConnections\nYUPIIK_BATCH_BACKEND_DATASOURCE_MAXCONNECTIONS\nMax connections in the pool.\nyupiik.batch.backend.datasource.minEvictableIdleTime\nYUPIIK_BATCH_BACKEND_DATASOURCE_MINEVICTABLEIDLETIME\nHow long to await before a connection is considered idled and evictable.\nyupiik.batch.backend.datasource.minIdle\nYUPIIK_BATCH_BACKEND_DATASOURCE_MINIDLE\nMin connections in the pool.\nyupiik.batch.backend.datasource.password\nYUPIIK_BATCH_BACKEND_DATASOURCE_PASSWORD\nDatasource password.\nyupiik.batch.backend.datasource.removeAbandoned\nYUPIIK_BATCH_BACKEND_DATASOURCE_REMOVEABANDONED\nShould connections be removed when abandoned (see related timeout).\nyupiik.batch.backend.datasource.removeAbandonedTimeout\nYUPIIK_BATCH_BACKEND_DATASOURCE_REMOVEABANDONEDTIMEOUT\nThe time in seconds before a connection can be considered abandoned.\nyupiik.batch.backend.datasource.testOnBorrow\nYUPIIK_BATCH_BACKEND_DATASOURCE_TESTONBORROW\nShould connections be tested on borrow time.\nyupiik.batch.backend.datasource.testOnReturn\nYUPIIK_BATCH_BACKEND_DATASOURCE_TESTONRETURN\nShould connections be tested on return to the pool time.\nyupiik.batch.backend.datasource.testWhileIdle\nYUPIIK_BATCH_BACKEND_DATASOURCE_TESTWHILEIDLE\nShould connections be tested in background.\nyupiik.batch.backend.datasource.timeBetweenEvictionRuns\nYUPIIK_BATCH_BACKEND_DATASOURCE_TIMEBETWEENEVICTIONRUNS\nTime between background evictions in ms.\nyupiik.batch.backend.datasource.url *\nYUPIIK_BATCH_BACKEND_DATASOURCE_URL\nDatasource URL.\nyupiik.batch.backend.datasource.username\nYUPIIK_BATCH_BACKEND_DATASOURCE_USERNAME\nDatasource username.\nyupiik.batch.backend.datasource.validationQuery\nYUPIIK_BATCH_BACKEND_DATASOURCE_VALIDATIONQUERY\nValidation query to validate the connection when enabled.\nyupiik.batch.backend.datasource.validationQueryTimeout\nYUPIIK_BATCH_BACKEND_DATASOURCE_VALIDATIONQUERYTIMEOUT\nHow long to await for the validation query.\nyupiik.batch.backend.queries.countAllJobs\nYUPIIK_BATCH_BACKEND_QUERIES_COUNTALLJOBS\nCount all jobs SQL query (for portability), ${table} is replaced by the table name.\nyupiik.batch.backend.queries.findAllJobs\nYUPIIK_BATCH_BACKEND_QUERIES_FINDALLJOBS\nFind all jobs with pagination SQL query (for portability), ${table} is replaced by the table name. Parameters can be ${pageSize}, ${firstIndex} - inclusive, ${lastIndex} - exclusive, or ${where} which would be replaced by a name where clause (`WHERE name = ? `).\nyupiik.batch.backend.queries.findJobById\nYUPIIK_BATCH_BACKEND_QUERIES_FINDJOBBYID\nFind a job by id SQL query (for portability), ${table} is replaced by the table name.\nyupiik.batch.backend.queries.findLastExecutions\nYUPIIK_BATCH_BACKEND_QUERIES_FINDLASTEXECUTIONS\nSQL query (for portability) to find last execution of each batch, ${table} is replaced by the table name.\nyupiik.batch.backend.queries.findStepsByJobId\nYUPIIK_BATCH_BACKEND_QUERIES_FINDSTEPSBYJOBID\nFind aall steps related to a job id SQL query (for portability), ${table} is replaced by the step table name.\nyupiik.batch.backend.tomcat.accessLogPattern\nYUPIIK_BATCH_BACKEND_TOMCAT_ACCESSLOGPATTERN\nTomcat access log pattern.\nyupiik.batch.backend.tomcat.port\nYUPIIK_BATCH_BACKEND_TOMCAT_PORT\nTomcat port.\nyupiik.batch.backend.tomcat.webUsers\nYUPIIK_BATCH_BACKEND_TOMCAT_WEBUSERS\nList of allowed users - by default all are. It uses a properties syntax: user=password. Security uses a web BASIC mecanism.\nyupiik.batch.frontend.extensionsJs\nYUPIIK_BATCH_FRONTEND_EXTENSIONSJS\nJavascript path to a Yupiik Batch frontend extension. Script is injected just before yupiik-batch main one, i.e. after libraries ones but note they are minified wih webpack.","title":"Yupiik Yupiik Batch","url":"//yupiik.github.io/yupiik-batch/generated/ui.configuration.html"}]